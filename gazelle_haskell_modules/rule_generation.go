package gazelle_haskell_modules

import (
	"encoding/json"
	"fmt"
	"log"
	"path"
	"path/filepath"

    "github.com/bazelbuild/buildtools/build"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/bazelbuild/rules_go/go/tools/bazel"

	"os/exec"
	"strings"
)

// Extracts the source files from Haskell rules and creates
// haskell_module rules to build them.
//
// For existing haskell_module rules, it sets the indexing_mod_name and originating_rule
// private attributes as a side effect!
// They are needed when indexing the rule.
func rulesToRuleInfos(pkgRoot string, rules []*rule.Rule, repo string, pkg string) []*RuleInfo {
	ruleInfoss0, originatingRules := nonHaskellModuleRulesToRuleInfos(pkgRoot, rules, repo, pkg)
	ruleInfoss1 := haskellModuleRulesToRuleInfos(pkgRoot, rules, repo, pkg, originatingRules)
	return concatRuleInfos(append(ruleInfoss0, ruleInfoss1...))
}

// Yields the rule infos and a map of dependency labels to the rule that
// has that dependency. If multiple rules have the same dependency only one
// of them ends up in the entry of the dependency.
//
func nonHaskellModuleRulesToRuleInfos(
	pkgRoot string,
	rules []*rule.Rule,
	repo string,
	pkg string,
) ([][]*RuleInfo, map[label.Label]*rule.Rule) {
	ruleInfoss := make([][]*RuleInfo, 0, 100)
	originatingRules := make(map[label.Label]*rule.Rule, 100)
	// Analyze non-haskell_module rules
	for _, r := range rules {
		if !isNonHaskellModule(r.Kind()) || !shouldModularize(r) {
			continue
		}
		srcs, err := srcsFromRuleExceptKeep(pkgRoot, r.Attr("srcs"))
		handleRuleError(err, r, "srcs")

		modules, err := depsFromRule(r.Attr("modules"), repo, pkg)
		handleRuleError(err, r, "modules")

		modDatas := haskellModulesToModuleData(srcs)
		ruleInfos := make([]*RuleInfo, len(modDatas))
		moduleLabels := make(map[label.Label]bool, len(modules) + len(srcs))
		for i, modData := range modDatas {
			ruleInfos[i] = &RuleInfo {
				OriginatingRule: r,
				ModuleData: modData,
				Modules: modules,
			}
			moduleLabels[label.New(repo, pkg, ruleNameFromRuleInfo(ruleInfos[i]))] = true
		}
		ruleInfoss = append(ruleInfoss, ruleInfos)

		for mod, _ := range modules {
			originatingRules[mod] = r
			moduleLabels[mod] = true
		}

		r.SetPrivateAttr("module_labels", moduleLabels)
	}
	return ruleInfoss, originatingRules
}

// originatingRules is used to determine which rule is originating a haskell_module
// rule, which is used in turn to determine which modules from the same originating
// rule are meant in imports.
func haskellModuleRulesToRuleInfos(
	pkgRoot string,
	rules []*rule.Rule,
	repo string,
	pkg string,
    originatingRules map[label.Label]*rule.Rule,
) [][]*RuleInfo {
	ruleInfoss := make([][]*RuleInfo, 0, 100)
	// Analyze haskell_module rules
	for _, r := range rules {
		if r.Kind() != "haskell_module" {
			continue
		}

		src := path.Join(pkgRoot, r.AttrString("src"))

		rLabel := label.New(repo, pkg, r.Name())
		originatingRule, ok := originatingRules[rLabel]
		if !ok {
			continue
		}

		modDatas := haskellModulesToModuleData([]string{src})
		ruleInfo := RuleInfo {
			OriginatingRule: originatingRule,
			ModuleData: modDatas[0],
			Modules: map[label.Label]bool{},
		}

		ruleInfoss = append(ruleInfoss, []*RuleInfo{&ruleInfo})

		r.SetPrivateAttr("indexing_mod_name", ruleInfo.ModuleData.ModuleName)
		r.SetPrivateAttr("originating_rule", ruleInfo.OriginatingRule)
	}
	return ruleInfoss
}

const HIMPORTSCAN_PATH = "himportscan/himportscan"

// Collects the imported modules from every sourcefile
//
// Module file paths must be absolute.
func haskellModulesToModuleData(moduleFiles []string) []*ModuleData {
	himportscan, err := bazel.Runfile(HIMPORTSCAN_PATH)
	if err != nil {
		log.Fatal(err)
	}
	cmd := exec.Command(himportscan)

	cmd.Stdin = strings.NewReader(strings.Join(moduleFiles, "\n"))
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("%s", out)
		log.Fatal(err)
	}
	var modDatas []*ModuleData
	err = json.Unmarshal(out, &modDatas)
	if err != nil {
		log.Printf("Incorrect json: %s\n", out)
		log.Fatal(err)
	}
	return modDatas
}

func infoToRules(pkgRoot string, ruleInfos []*RuleInfo) language.GenerateResult {

	theRules := make([]*rule.Rule, len(ruleInfos))
	theImports := make([]interface{}, len(ruleInfos))
	for i, ruleInfo := range ruleInfos {
		ruleName := ruleNameFromRuleInfo(ruleInfo)
		r := rule.NewRule("haskell_module", ruleName)
		r.SetPrivateAttr("indexing_mod_name", ruleInfo.ModuleData.ModuleName)
		r.SetPrivateAttr("originating_rule", ruleInfo.OriginatingRule)
		file, _ := filepath.Rel(pkgRoot, ruleInfo.ModuleData.FilePath)
		r.SetAttr("src", file)
		r.SetAttr("src_strip_prefix", srcStripPrefix(file, ruleInfo.ModuleData.ModuleName))
		r.AddComment("# rule generated by gazelle_haskell_modules")

		theRules[i] = r
		theImports[i] = &HModuleImportData {
			OriginatingRule: ruleInfo.OriginatingRule,
			ImportedModules: ruleInfo.ModuleData.ImportedModules,
			UsesTH: ruleInfo.ModuleData.UsesTH,
		}
	}

	return language.GenerateResult{
		Gen:     theRules,
		Imports: theImports,
	}
}

func addNonHaskellModuleRules(
	c *Config,
	pkgRoot string,
	repo string,
	pkg string,
	gen language.GenerateResult,
	rules []*rule.Rule,
) language.GenerateResult {
	haskellRules := make([]*rule.Rule, 0, len(rules))
	imports := make([]interface{}, 0, len(rules))
	for _, r := range rules {
		if !shouldModularize(r) {
			continue
		}
		if isNonHaskellModule(r.Kind()) {
			newr := rule.NewRule(r.Kind(), r.Name())
			for _, k := range r.AttrKeys() {
				// Empty lists in attributes crash gazelle, so we remove them here.
				if k != "srcs" && k != "modules" && !isEmptyListExpr(r.Attr(k)) {
					newr.SetAttr(k, r.Attr(k))
				}
			}

			srcs, err := srcsFromRuleExceptKeep(pkgRoot, r.Attr("srcs"))
			handleRuleError(err, r, "srcs")
			modules, err := depsFromRule(r.Attr("modules"), repo, pkg)
			handleRuleError(err, r, "modules")
			deps, err := depsFromRule(r.Attr("deps"), repo, pkg)
			handleRuleError(err, r, "deps")
			narrowedDeps, err := depsFromRule(r.Attr("narrowed_deps"), repo, pkg)
			handleRuleError(err, r, "narrowed_deps")
			appendLabelMaps(deps, narrowedDeps)
			imports = append(imports, &HRuleImportData {
				Deps: deps,
				Modules: modules,
				Srcs: srcs,
			})
			haskellRules = append(haskellRules, newr)

			r.SetPrivateAttr("library_dep_labels", deps)
			newr.SetPrivateAttr("library_dep_labels", deps)
			newr.SetPrivateAttr("module_labels", r.PrivateAttr("module_labels"))
		}
	}
	return language.GenerateResult{
		Gen:     append(gen.Gen, haskellRules...),
		Imports: append(gen.Imports, imports...),
	}
}

func appendLabelMaps(a map[label.Label]bool, b map[label.Label]bool) {
	for k, v := range b {
		a[k] = v
	}
}

func handleRuleError(err error, r *rule.Rule, attr string) {
	if err != nil {
		fmt.Println("Error when analyzing target", r.Name())
		fmt.Println(attr, "=", build.FormatString(r.Attr(attr)))
		log.Fatal(err)
	}
}

func concatRuleInfos(xs [][]*RuleInfo) []*RuleInfo {
	s := 0
	for _, x := range xs {
		s += len(x)
	}
	ys := make([]*RuleInfo, s)
	i := 0
	for _, x := range xs {
		for _, y := range x {
			ys[i] = y
			i++
		}
	}
	return ys
}

func NotShouldKeep(expr build.Expr) bool {
	return !rule.ShouldKeep(expr)
}

func ConstTrue(expr build.Expr) bool {
	return true
}

// Collects the source files referenced in the given expression
func srcsFromRuleExceptKeep(pkgRoot string, expr build.Expr) ([]string, error) {
	srcs, err := getSources(expr, NotShouldKeep)
	if err != nil {
		return nil, err
	}

	xs := make([]string, len(srcs))
	i := 0
	for f, _ := range srcs {
		xs[i] = path.Join(pkgRoot, f)
		i++
	}

	return xs, nil
}

// Collects the dependencies referenced in the given expression
func depsFromRule(expr build.Expr, repo string, pkg string) (map[label.Label]bool, error) {
	deps, err := getLabelsFromListExpr(expr)
	if err != nil {
		return nil, err
	}

	xs := make(map[label.Label]bool, len(deps))
	for lbl, _ := range deps {
		xs[abs(lbl, repo, pkg)] = true
	}

	return xs, nil
}

func setVisibilities(f *rule.File, rules []*rule.Rule) {
	if f == nil || !f.HasDefaultVisibility() {
		for _, r := range rules {
			r.SetAttr("visibility", []string{"//visibility:public"})
		}
	}
}

type ModuleData struct {
	ModuleName string
	FilePath  string
	ImportedModules []string
	UsesTH bool
}

type RuleInfo struct {
	OriginatingRule *rule.Rule
	Modules map[label.Label]bool // Absolute labels of the modules in the library, empty if not a library
	ModuleData *ModuleData
}

type HModuleImportData struct {
	OriginatingRule *rule.Rule
	ImportedModules []string
	UsesTH bool
}

type HRuleImportData struct {
	Deps map[label.Label]bool // Absolute labels of deps of the library/binary/test
	Modules map[label.Label]bool // Absolute labels of the modules in the library, empty if not a library
	Srcs []string
}

func getLabelsFromListExpr(expr build.Expr) (map[label.Label]bool, error) {
	switch expr.(type) {
	case nil:
        return map[label.Label]bool{}, nil
	case *build.ListExpr:
		exprList := expr.(*build.ListExpr).List
		xs := make(map[label.Label]bool, len(exprList))
		for _, e := range exprList {
			switch e.(type) {
			case *build.StringExpr:
				lbl, err := ParseLabel(e.(*build.StringExpr).Value)
				if err != nil {
					return nil, err
				}
				xs[lbl] = true
			default:
				return nil, fmt.Errorf("Unhandled expression type %T (expected a string)", e)
            }
        }
        return xs, nil
    default:
        return nil, fmt.Errorf("Unhandled expression type %T (expected a list)", expr)
    }
}

// We use a patched parsing for labels, as the parser from gazelle can't understand
// labels of the form "@repo", supposed to mean "@repo//:repo".
func ParseLabel(v string) (label.Label, error) {
	if strings.HasPrefix(v, "@") && !strings.Contains(v, "//") && !strings.Contains(v, ":") {
		v = fmt.Sprintf("%s//:%s",v, v[1:])
	}
	return label.Parse(v)
}

func getSources(expr build.Expr, p func(build.Expr) bool) (map[string]bool, error) {
	xs, err := getStringListP(expr, p)
	if err != nil {
		return nil, err
	}
	sourceMap := make(map[string]bool, len(xs))
	for _, x := range xs {
		sourceMap[x] = true
	}
	return sourceMap, nil
}

// Similar to (*Rule) AttrStrings(key string) []string
// but yields an empty list if the attribute isn't set, and
// gives an error if the attribute is set to something that
// isn't a list.
//
// Yields only the values satisfying the given predicate.
func getStringListP(expr build.Expr, p func(build.Expr) bool) ([]string, error) {
	switch expr.(type) {
	case nil:
		return []string{}, nil
	case *build.ListExpr:
		exprList := expr.(*build.ListExpr).List
		xs := make([]string, 0, len(exprList))
		for _, e := range exprList {
			switch e.(type) {
			case *build.StringExpr:
				estr := e.(*build.StringExpr)
				if p(estr) {
					xs = append(xs, estr.Value)
				}
			default:
				return nil, fmt.Errorf("Unhandled expression type %T (expected a string)", e)
			}
		}
		return xs, nil
	default:
		return nil, fmt.Errorf("Unhandled expression type %T (expected a list)", expr)
	}
}

func getStringList(expr build.Expr) ([]string, error) {
	return getStringListP(expr, ConstTrue)
}

func isNonHaskellModule(kind string) bool {
	return kind == "haskell_library" ||
		kind == "haskell_binary" ||
		kind == "haskell_test"
}

// Computes the prefix of file that doesn't correspond with
// the module hierarchy.
//
// srcStripPrefix("/a/B/C", "B.C") == "/a"
//
// Actually, it doesn't check that the components of
// the module name match the path, so
//
// srcStripPrefix("/a/B/C", "D.E") == "/a"
//
func srcStripPrefix(file, modName string) string {
   numComponents := strings.Count(modName, ".") + 1
   dir := file
   for i := 0; i < numComponents; i++ {
     dir = filepath.Dir(dir)
   }
   return dir
}

func isEmptyListExpr(expr build.Expr) bool {
	switch expr.(type) {
	case *build.ListExpr:
		return len(expr.(*build.ListExpr).List) == 0
	default:
		return false
	}
}

func ruleNameFromRuleInfo(ruleInfo *RuleInfo) string {
	if ruleInfo.OriginatingRule.Kind() != "haskell_module" {
		return ruleInfo.OriginatingRule.Name() + "." + ruleInfo.ModuleData.ModuleName
	} else {
		return ruleInfo.OriginatingRule.Name()
	}
}

func shouldModularize(r *rule.Rule) bool {
	if r.ShouldKeep() {
		return false
	}
	for _, c := range r.Comments() {
		if strings.Trim(c, "# ") == "gazelle_haskell_modules:keep" {
			return false
		}
	}
	return true
}
